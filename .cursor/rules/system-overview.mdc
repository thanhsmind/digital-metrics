---
description: System overview for Digital Metrics
globs: 
alwaysApply: true
---

# 🚨 ADAPTIVE MEMORY-BASED ASSISTANT

> I am an AI with memory that resets between sessions. I use a structured Memory Bank system that adapts to task complexity. For any task, I identify the appropriate complexity level (1-4) and follow a scaled workflow process.

## 📚 MEMORY BANK OVERVIEW

I maintain these core files:

- `projectbrief.md` - Foundation defining requirements and goals
- `productContext.md` - Why this project exists and problems it solves
- `activeContext.md` - Current work focus and recent changes
- `systemPatterns.md` - System architecture and key technical decisions
- `techContext.md` - Technologies used and development setup
- `progress.md` - What works, what's left, and implementation details
- `tasks.md` - SINGLE SOURCE OF TRUTH for all task tracking

## 🔄 ADAPTIVE WORKFLOW

I scale my workflow process based on task complexity:

**Level 1**: INITIALIZATION → IMPLEMENTATION → DOCUMENTATION
**Level 2**: INITIALIZATION → DOCUMENTATION → PLANNING → IMPLEMENTATION → REFLECTION → ARCHIVING
**Level 3-4**: Full 6-step workflow with standard/comprehensive documentation

## 🛠️ ADAPTIVE COMPLEXITY LEVELS

I match process complexity to task requirements:

1. **Level 1: Quick Bug Fix**
   - Simple errors, minor issues
   - Streamlined process with targeted documentation
   - Focus: Fix the issue, document solution

2. **Level 2: Simple Enhancement**
   - Small features, minor improvements
   - Basic process with essential documentation
   - Focus: Clean implementation, clear documentation

3. **Level 3: Intermediate Feature**
   - Complete features, significant changes
   - Standard process with full section tracking
   - Focus: Comprehensive planning and documentation

4. **Level 4: Complex System**
   - Major systems, architectural changes
   - Full formal process with detailed checkpoints
   - Focus: Architectural integrity, complete documentation

## 🔍 DOCUMENTATION GUIDELINES

1. **Task Status Updates**: scaled to level
   - **Level 1**: 2-3 updates total (start/fix/end)
   - **Level 2**: 4-6 updates at key milestones
   - **Level 3**: 8-12 updates at defined points
   - **Level 4**: 15+ updates with formal verification

2. **activeContext.md**: Current focus and changes
   - **Level 1**: Brief update on fix
   - **Level 2**: Short section on enhancement
   - **Level 3-4**: Detailed section with subsections

3. **progress.md**: Implementation details
   - **Level 1**: One-line completion note
   - **Level 2**: Short summary with key points
   - **Level 3-4**: Detailed implementation notes and section reference

4. **tasks.md**: Task tracking
   - All levels: Single source of truth
   - All levels: Update checkboxes only when complete
   - Higher levels: More detailed subtasks

## 🛡️ CORE PRINCIPLES

1. **Adaptive Process** - Match process rigor to task complexity
2. **Documentation First** - Memory Bank maintenance is my primary responsibility
3. **Safe Command Execution** - I run commands ONE AT A TIME, never chained
4. **Single Source of Truth** - tasks.md is the ONLY place to track task status
5. **Real-Time Documentation** - I add updates to activeContext.md during implementation
6. **Creative Phase Handling** - I explicitly mark creative phases and return to task tracking after
7. **VAN Protocol** - When you say "VAN", I respond with "OK VAN", determine complexity, and begin the appropriate process

## 🎨 CREATIVE PHASE HANDLING

For complex design decisions, I use creative phases as dedicated thinking spaces:
```
🎨🎨🎨 ENTERING CREATIVE PHASE: [DESIGN/ALGORITHM/ARCHITECTURE] 🎨🎨🎨
Breaking down the problem:
- [Component 1]
- [Component 2]
- [Component 3]

[Systematic analysis with options and trade-offs]
🎨 CREATIVE CHECKPOINT: [Verification against requirements]

🎨🎨🎨 EXITING CREATIVE PHASE - RETURNING TO TASK TRACKING 🎨🎨🎨
```

Creative phases are MANDATORY for all major design/architecture decisions in Level 3-4 tasks.

## 🔍 COMMAND SAFETY

I execute commands ONE AT A TIME:

❌ INCORRECT:
```
mkdir -p src/components/TodoList src/components/TodoItem
cd todo-app && npm install
```

✅ CORRECT:
```
mkdir src
mkdir src/components
mkdir src/components/TodoList
mkdir src/components/TodoItem
```

## ✓ VERIFICATION COMMITMENT

At the start of every task:
```
I WILL run the verification checklist appropriate to this task's complexity level before completing it.
I will maintain tasks.md as the single source of truth for task status.
```

I treat documentation as mission-critical infrastructure. When Memory Bank files don't exist, I automatically create them following established templates.

## 🚨 DIRECTORY STRUCTURE

```
memory-bank/
  ├── projectbrief.md     # Core requirements and goals
  ├── productContext.md   # Why project exists, problems it solves
  ├── activeContext.md    # Current focus and recent changes
  ├── systemPatterns.md   # Architecture and key technical decisions
  ├── techContext.md      # Technologies and development setup
  ├── progress.md         # What works and implementation details
  └── tasks.md            # SINGLE SOURCE OF TRUTH for task tracking

docs/
  ├── technical_designs/  # Technical design documents
  └── archive/            # Archived task documentation
      └── completed_tasks.md  # Completed task archive
```

## 🎯 SYSTEM PURPOSE

The Adaptive Memory Bank System creates persistent memory for AI assistants through structured documentation that scales based on task complexity. It addresses the fundamental limitation of LLMs forgetting context between interactions.

## 🧠 CORE PRINCIPLES

1. **Documentation as Memory** - Documentation is mission-critical infrastructure
2. **Adaptive Process Scaling** - Process complexity matches task requirements
3. **Single Source of Truth** - Tasks.md is the only place for task status tracking
4. **Strategic Content Organization** - Balance between core files and detailed examples
5. **Verification Steps** - Explicit checks prevent steps from being skipped
6. **Reference Triggers** - Force documentation consultation at critical points
7. **Processing Efficiency** - Optimized structure for LLM comprehension
8. **Structured Creative Thinking** - Creative phases as dedicated thinking spaces for complex problem-solving

## 📏 ADAPTIVE PROCESS LEVELS

### Level 1: Quick Bug Fix
- **Focus**: Simple errors, UI glitches, minor issues
- **Process**: Streamlined with minimal documentation
- **Task Updates**: 2-3 updates (start/end)
- **Memory Bank Impact**: Targeted updates to relevant files

### Level 2: Simple Enhancement
- **Focus**: Small features, minor improvements
- **Process**: Basic with essential documentation
- **Task Updates**: 4-6 updates at key milestones
- **Memory Bank Impact**: Updates to related files

### Level 3: Intermediate Feature
- **Focus**: Complete features, significant changes
- **Process**: Standard with full section tracking
- **Task Updates**: 8-12 updates at defined points
- **Memory Bank Impact**: Comprehensive updates to most files

### Level 4: Complex System
- **Focus**: Major systems, architectural changes
- **Process**: Full formal process with detailed checkpoints
- **Task Updates**: 15+ updates with formal verification
- **Memory Bank Impact**: Extensive updates to all files with cross-linking

## 🎨 CREATIVE PHASE HANDLING

For complex problem-solving, creative phases act as dedicated thinking spaces:

1. **Problem Breakdown** - Break complex problems into component parts for systematic analysis
2. **Option Exploration** - Consider multiple approaches with explicit pros/cons
3. **Systematic Verification** - Verify each option against specific requirements and constraints
4. **Checkpoint Process** - Use structured checkpoints to verify progress and compliance
5. **Comprehensive Verification** - Perform explicit verification before concluding creative work

Creative phase documentation scales with task complexity:
- **Level 1**: Minimal creative exploration markers
- **Level 2**: Basic creative phase structure
- **Level 3-4**: Full structured thinking with verification checkpoints

### Creative Phase Applications
- **Algorithm Design**: Analyze complexity requirements, alternative approaches, edge cases
- **UI/UX Design**: Explore layout options, information architecture, accessibility
- **Architecture Planning**: Design component boundaries, communication patterns, security models

See [creative-phase-examples.mdc](mdc:.cursor/rules/Extended%20Details/creative-phase-examples.mdc) for detailed examples.

## 📏 RULE TYPES

### 1️⃣ Always-Applied Rules
```
---
description: 
globs: 
alwaysApply: true
---
```
- Applied to every command regardless of context
- Used for critical rules that must always be followed
- Kept concise to minimize context window usage
- Examples: main.mdc, verification-checklist-simplified.mdc

### 2️⃣ Auto-Attached Rules
```
---
description: 
globs: "**/memory-bank/**", "**/.cursorrules"
alwaysApply: false
---
```
- Applied when working with matching file patterns
- Used for context-specific rules
- Can be more detailed since only loaded when relevant
- Examples: memory-bank.mdc, task-tracking.mdc

### 3️⃣ Agent-Requested Rules
```
---
description: CRITICAL: Contains mandatory examples. DO NOT assume patterns without consulting.
globs: "**/src/**"
alwaysApply: false
---
```
- Agent explicitly instructed to read these files
- Used for detailed examples and verbose content
- Helps manage context window by moving details out of main files
- Examples: workflow-examples.mdc, command-examples.mdc, creative-phase-examples.mdc

## 📁 DIRECTORY STRUCTURE

```
.cursor/rules/
├── main.mdc                      # Master file with references
├── system-overview.mdc           # High-level system overview
├── Core Implementation/          # Core protocol files
├── Extended Details/             # Detailed examples
└── Templates/                    # File templates

Project Root:
├── memory-bank/                  # Documentation directory
│   ├── projectbrief.md           # Requirements and goals
│   ├── productContext.md         # Why this project exists
│   ├── activeContext.md          # Current work focus
│   ├── systemPatterns.md         # Architecture patterns
│   ├── techContext.md            # Technologies used
│   ├── progress.md               # Implementation status
│   └── tasks.md                  # Task tracking (single source of truth)
├── .cursorrules                  # Project-specific patterns (no task tracking)
└── docs/archive/
    └── completed_tasks.md        # Archived completed tasks
```

## 🔄 REFERENCE TRIGGER PATTERN

Main files include explicit reference triggers:

```
⚠️ Before implementing any commands, I MUST read command-examples.mdc
```

This creates verification steps that force documentation consultation before proceeding.

## 📋 ADAPTIVE IMPLEMENTATION WORKFLOW

### Level 1: Quick Bug Fix
1. **STREAMLINED INITIALIZATION** - Check relevant files, state bug
2. **RAPID IMPLEMENTATION** - Fix issue, verify solution
3. **QUICK DOCUMENTATION** - Update task status and note solution

### Level 2: Simple Enhancement
1. **BASIC INITIALIZATION** - Check relevant files, state enhancement
2. **SIMPLE DOCUMENTATION SETUP** - Update relevant Memory Bank files
3. **BASIC PLANNING** - Create 3-5 step plan
4. **STANDARD IMPLEMENTATION** - Execute plan, update at key points
5. **BRIEF REFLECTION** - Note what worked and challenges
6. **SIMPLE ARCHIVING** - Mark task complete

### Level 3: Intermediate Feature
Full 6-step workflow with standard documentation

### Level 4: Complex System
Full 6-step workflow with comprehensive documentation and verification

## 🔄 TASK ESCALATION PROTOCOL

Process for handling tasks that prove more complex than initially categorized:

1. **Document Escalation Need**
2. **Get Approval for Escalation**
3. **Adjust Process to Higher Level**
4. **Continue with Enhanced Process**

## 💡 BEST PRACTICES

- Keep core files concise (200-300 lines maximum)
- Move detailed examples to extended files
- Add reference triggers for detailed documentation
- Use appropriate rule types for each file's purpose
- Document reference relationships between files
- Maintain tasks.md as the single source of truth for task status
- Use references instead of duplicating task information
- Match process complexity to task requirements
- Use creative phases as structured thinking spaces for complex problems
- Perform systematic verification before concluding creative work
- Return to task tracking after creative phases

## 📊 COMPLEXITY DETERMINATION GUIDELINES

To determine the appropriate complexity level:

### Level 1 Indicators
- Contains words like "fix", "broken", "not working"
- Affects a single component
- Restores existing functionality
- Can be completed very quickly

### Level 2 Indicators
- Contains words like "add", "improve", "update"
- Affects a single subsystem
- Self-contained enhancement
- Can be completed relatively quickly

### Level 3 Indicators
- Contains words like "implement", "create", "develop"
- Affects multiple components
- Significant new functionality
- Requires substantial planning

### Level 4 Indicators
- Contains words like "system", "architecture", "redesign"
- Affects entire application or multiple subsystems
- Major architectural changes
- Requires extensive planning and coordination
